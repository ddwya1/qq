<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SillyTavern è§’è‰²å¡æ€§åˆ«è½¬æ¢å·¥å…·</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
        }
        
        :root {
            --glass-bg: rgba(30, 30, 40, 0.85);
            --glass-border: rgba(255, 255, 255, 0.1);
            --accent-pink: #ff6b9d;
            --accent-blue: #4fc3f7;
            --accent-purple: #b388ff;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f1a 100%);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .glass {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
        }
        
        .glass-input, .glass-select {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: white;
            transition: all 0.3s ease;
        }
        
        .glass-input:focus, .glass-select:focus {
            outline: none;
            border-color: var(--accent-purple);
            box-shadow: 0 0 20px rgba(179, 136, 255, 0.3);
        }
        
        .glass-select {
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='white' viewBox='0 0 24 24'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 20px;
            padding-right: 40px;
        }
        
        .glass-select option {
            background: #1a1a2e;
            color: white;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--accent-pink), var(--accent-purple));
            border: none;
            border-radius: 12px;
            color: white;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 157, 0.3);
        }
        
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 157, 0.4);
        }
        
        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: white;
            transition: all 0.3s ease;
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.15);
        }
        
        .btn-secondary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-icon {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: white;
            padding: 8px 12px;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        
        .btn-icon:hover:not(:disabled) {
            background: var(--accent-purple);
            border-color: var(--accent-purple);
        }
        
        .btn-icon:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .toggle-btn {
            position: relative;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 25px;
            padding: 4px;
            display: flex;
            gap: 4px;
        }
        
        .toggle-option {
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            z-index: 1;
        }
        
        .toggle-option.active {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            color: white;
        }
        
        .toggle-option:not(.active) {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .file-drop-zone {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .file-drop-zone:hover, .file-drop-zone.dragover {
            border-color: var(--accent-purple);
            background: rgba(179, 136, 255, 0.1);
        }
        
        .progress-bar {
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-pink), var(--accent-purple));
            transition: width 0.3s ease;
        }
        
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 16px 24px;
            border-radius: 12px;
            color: white;
            font-weight: 500;
            z-index: 9999;
            animation: slideIn 0.3s ease;
            max-width: calc(100vw - 40px);
        }
        
        .toast.success {
            background: linear-gradient(135deg, #00c853, #00bfa5);
        }
        
        .toast.error {
            background: linear-gradient(135deg, #ff5252, #ff1744);
        }
        
        .toast.info {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .diff-added {
            background: rgba(0, 200, 83, 0.3);
            color: #69f0ae;
            padding: 2px 4px;
            border-radius: 4px;
        }
        
        .diff-removed {
            background: rgba(255, 82, 82, 0.3);
            color: #ff8a80;
            padding: 2px 4px;
            border-radius: 4px;
            text-decoration: line-through;
        }
        
        .preview-section {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .preview-section::-webkit-scrollbar {
            width: 6px;
        }
        
        .preview-section::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }
        
        .preview-section::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        .card-preview-img {
            max-width: 120px;
            max-height: 160px;
            border-radius: 12px;
            object-fit: cover;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        
        .status-indicator.pending {
            background: #ffd54f;
        }
        
        .status-indicator.processing {
            background: var(--accent-blue);
            animation: pulse 1s infinite;
        }
        
        .status-indicator.done {
            background: #69f0ae;
        }
        
        .status-indicator.error {
            background: #ff5252;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .field-item {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
        }
        
        .collapsible-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .collapsible-content.open {
            max-height: 2000px;
        }
        
        .chevron {
            transition: transform 0.3s ease;
        }
        
        .chevron.open {
            transform: rotate(180deg);
        }
        
        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
            display: inline-block;
            margin-left: 8px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        @media (max-width: 640px) {
            .toggle-option {
                padding: 8px 14px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body class="text-white p-4 pb-20">
    <div class="max-w-2xl mx-auto">
        <!-- Header -->
        <div class="text-center mb-6">
            <h1 class="text-2xl font-bold bg-gradient-to-r from-pink-400 via-purple-400 to-blue-400 bg-clip-text text-transparent">
                ğŸ­ è§’è‰²å¡æ€§åˆ«è½¬æ¢å·¥å…·
            </h1>
            <p class="text-gray-400 text-sm mt-2">SillyTavern Character Card Gender Converter</p>
        </div>

        <!-- API Settings -->
        <div class="glass p-4 mb-4">
            <div class="collapsible-header" onclick="toggleCollapsible('api-settings')">
                <h2 class="text-lg font-semibold flex items-center">
                    <span class="mr-2">âš™ï¸</span> API è®¾ç½®
                </h2>
                <span class="chevron" id="api-settings-chevron">â–¼</span>
            </div>
            <div class="collapsible-content open" id="api-settings">
                <div class="mt-4 space-y-3">
                    <div>
                        <label class="block text-sm text-gray-400 mb-1">API URL</label>
                        <input type="text" id="apiUrl" 
                               class="glass-input w-full px-4 py-3 text-sm"
                               placeholder="https://api.openai.com/v1/chat/completions"
                               value="https://api.deepseek.com/v1/chat/completions"
                               onchange="clearModelList()">
                    </div>
                    <div>
                        <label class="block text-sm text-gray-400 mb-1">API Key</label>
                        <input type="password" id="apiKey" 
                               class="glass-input w-full px-4 py-3 text-sm"
                               placeholder="sk-xxxxxxxxxxxxxxxx"
                               onchange="clearModelList()">
                    </div>
                    <div>
                        <label class="block text-sm text-gray-400 mb-1">é€‰æ‹©æ¨¡å‹</label>
                        <div class="flex gap-2">
                            <select id="modelSelect" 
                                    class="glass-select flex-1 px-4 py-3 text-sm"
                                    disabled>
                                <option value="">è¯·å…ˆåŠ è½½æ¨¡å‹åˆ—è¡¨</option>
                            </select>
                            <button id="loadModelsBtn" 
                                    class="btn-icon whitespace-nowrap"
                                    onclick="loadModels()">
                                ğŸ”„ åŠ è½½
                            </button>
                        </div>
                        <p class="text-xs text-gray-500 mt-1">
                            ğŸ’¡ å¡«å†™ API ä¿¡æ¯åï¼Œç‚¹å‡»"åŠ è½½"è·å–å¯ç”¨æ¨¡å‹
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Target Gender -->
        <div class="glass p-4 mb-4">
            <h2 class="text-lg font-semibold mb-3 flex items-center">
                <span class="mr-2">ğŸ¯</span> ç›®æ ‡æ€§åˆ«
            </h2>
            <div class="toggle-btn">
                <div class="toggle-option active" id="toggle-male" onclick="setTargetGender('male')">
                    â™‚ï¸ è½¬ä¸ºç”·æ€§ User
                </div>
                <div class="toggle-option" id="toggle-female" onclick="setTargetGender('female')">
                    â™€ï¸ è½¬ä¸ºå¥³æ€§ User
                </div>
            </div>
            <p class="text-xs text-gray-500 mt-3">
                ğŸ’¡ å°†è§’è‰²å¡ä¸­çš„ User æ€§åˆ«ç›¸å…³æè¿°è½¬æ¢ä¸ºç›®æ ‡æ€§åˆ«
            </p>
        </div>

        <!-- File Upload -->
        <div class="glass p-4 mb-4">
            <h2 class="text-lg font-semibold mb-3 flex items-center">
                <span class="mr-2">ğŸ“</span> å¯¼å…¥è§’è‰²å¡
            </h2>
            <div class="file-drop-zone p-8 text-center" id="dropZone" onclick="document.getElementById('fileInput').click()">
                <input type="file" id="fileInput" class="hidden" accept=".png,.json" onchange="handleFileSelect(event)">
                <div class="text-4xl mb-3">ğŸ“¤</div>
                <p class="text-gray-300">ç‚¹å‡»æˆ–æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„</p>
                <p class="text-sm text-gray-500 mt-1">æ”¯æŒ PNG è§’è‰²å¡ / JSON æ–‡ä»¶</p>
            </div>
            
            <!-- Card Preview -->
            <div id="cardPreview" class="hidden mt-4">
                <div class="flex items-start gap-4">
                    <img id="previewImage" class="card-preview-img" src="" alt="Card Preview">
                    <div class="flex-1 min-w-0">
                        <h3 id="cardName" class="font-semibold text-lg truncate"></h3>
                        <p id="cardCreator" class="text-sm text-gray-400"></p>
                        <p id="cardVersion" class="text-xs text-gray-500 mt-1"></p>
                        <div class="flex flex-wrap gap-2 mt-2">
                            <span class="text-xs px-2 py-1 bg-purple-500/20 rounded-full" id="cardSpec"></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Convert Button -->
        <button id="convertBtn" class="btn-primary w-full py-4 text-lg mb-4" onclick="startConversion()" disabled>
            ğŸ”„ å¼€å§‹è½¬æ¢
        </button>

        <!-- Progress -->
        <div id="progressSection" class="glass p-4 mb-4 hidden">
            <h2 class="text-lg font-semibold mb-3 flex items-center">
                <span class="mr-2">â³</span> è½¬æ¢è¿›åº¦
            </h2>
            <div class="progress-bar mb-3">
                <div class="progress-fill" id="progressBar" style="width: 0%"></div>
            </div>
            <div id="progressStatus" class="text-sm text-gray-400"></div>
            <div id="fieldProgress" class="mt-3 space-y-2"></div>
        </div>

        <!-- Diff Preview -->
        <div id="diffSection" class="glass p-4 mb-4 hidden">
            <h2 class="text-lg font-semibold mb-3 flex items-center">
                <span class="mr-2">ğŸ“</span> ä¿®æ”¹é¢„è§ˆ
            </h2>
            <div id="diffContent" class="space-y-4"></div>
        </div>

        <!-- Export -->
        <div id="exportSection" class="glass p-4 hidden">
            <h2 class="text-lg font-semibold mb-3 flex items-center">
                <span class="mr-2">ğŸ’¾</span> å¯¼å‡ºæ–‡ä»¶
            </h2>
            <div class="grid grid-cols-2 gap-3">
                <button class="btn-primary py-3" onclick="exportPNG()">
                    ğŸ“¥ ä¸‹è½½ PNG
                </button>
                <button class="btn-secondary py-3" onclick="exportJSON()">
                    ğŸ“„ ä¸‹è½½ JSON
                </button>
            </div>
        </div>

        <!-- Footer -->
        <div class="text-center text-gray-500 text-xs mt-8">
            <p>Made with â¤ï¸ for SillyTavern Community</p>
            <p class="mt-1">æ‰€æœ‰å¤„ç†å‡åœ¨æœ¬åœ°å®Œæˆï¼Œä»… AI è½¬æ¢éœ€è¦ç½‘ç»œ</p>
        </div>
    </div>

    <script>
        // ==================== å…¨å±€çŠ¶æ€ ====================
        let targetGender = 'male';
        let originalData = null;
        let convertedData = null;
        let originalPngBuffer = null;
        let originalFileName = '';
        let cardImageDataUrl = '';
        let availableModels = [];

        // ==================== Toast é€šçŸ¥ ====================
        function showToast(message, type = 'info', duration = 3000) {
            const toast = document.createElement('div');
            toast.className = 'toast ' + type;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(function() {
                toast.style.animation = 'slideIn 0.3s ease reverse';
                setTimeout(function() { toast.remove(); }, 300);
            }, duration);
        }

        // ==================== æŠ˜å é¢æ¿ ====================
        function toggleCollapsible(id) {
            const content = document.getElementById(id);
            const chevron = document.getElementById(id + '-chevron');
            content.classList.toggle('open');
            chevron.classList.toggle('open');
        }

        // ==================== æ€§åˆ«åˆ‡æ¢ ====================
        function setTargetGender(gender) {
            targetGender = gender;
            document.getElementById('toggle-male').classList.toggle('active', gender === 'male');
            document.getElementById('toggle-female').classList.toggle('active', gender === 'female');
        }

        // ==================== æ¨¡å‹åŠ è½½ ====================
        function clearModelList() {
            const select = document.getElementById('modelSelect');
            select.innerHTML = '<option value="">è¯·å…ˆåŠ è½½æ¨¡å‹åˆ—è¡¨</option>';
            select.disabled = true;
            availableModels = [];
        }

        async function loadModels() {
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const apiKey = document.getElementById('apiKey').value.trim();
            
            if (!apiUrl || !apiKey) {
                showToast('è¯·å…ˆå¡«å†™ API URL å’Œ API Key', 'error');
                return;
            }
            
            const btn = document.getElementById('loadModelsBtn');
            const originalText = btn.innerHTML;
            btn.disabled = true;
            btn.innerHTML = 'åŠ è½½ä¸­<span class="spinner"></span>';
            
            try {
                // æ„å»º models endpoint
                const baseUrl = apiUrl.replace(/\/chat\/completions\(/, '').replace(/\/\)/, '');
                const modelsUrl = baseUrl + '/models';
                
                const response = await fetch(modelsUrl, {
                    method: 'GET',
                    headers: {
                        'Authorization': 'Bearer ' + apiKey,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error('API è¯·æ±‚å¤±è´¥: ' + response.status + ' ' + response.statusText);
                }
                
                const data = await response.json();
                
                console.log('API è¿”å›æ•°æ®:', data); // è°ƒè¯•ç”¨
                
                if (!data.data || !Array.isArray(data.data)) {
                    throw new Error('API è¿”å›æ ¼å¼ä¸æ­£ç¡®');
                }
                
                availableModels = data.data
                    .filter(function(m) { return m.id; })
                    .sort(function(a, b) {
                        const aIsChat = a.id.toLowerCase().includes('chat');
                        const bIsChat = b.id.toLowerCase().includes('chat');
                        if (aIsChat && !bIsChat) return -1;
                        if (!aIsChat && bIsChat) return 1;
                        return a.id.localeCompare(b.id);
                    });
                
                if (availableModels.length === 0) {
                    throw new Error('æœªæ‰¾åˆ°å¯ç”¨æ¨¡å‹');
                }
                
                // å¡«å……ä¸‹æ‹‰æ¡† - ä½¿ç”¨ DOM æ–¹æ³•è€Œä¸æ˜¯æ¨¡æ¿å­—ç¬¦ä¸²
                const select = document.getElementById('modelSelect');
                select.innerHTML = ''; // æ¸…ç©º
                
                for (let i = 0; i < availableModels.length; i++) {
                    const model = availableModels[i];
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.id;
                    select.appendChild(option);
                }
                
                select.disabled = false;
                
                // è‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ª
                if (availableModels.length > 0) {
                    select.value = availableModels[0].id;
                }
                
                showToast('æˆåŠŸåŠ è½½ ' + availableModels.length + ' ä¸ªæ¨¡å‹', 'success');
                updateConvertButtonState();
                
            } catch (error) {
                console.error('åŠ è½½æ¨¡å‹å¤±è´¥:', error);
                showToast('åŠ è½½æ¨¡å‹å¤±è´¥: ' + error.message, 'error');
                clearModelList();
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalText;
            }
        }

        // ==================== æ–‡ä»¶æ‹–æ”¾ ====================
        const dropZone = document.getElementById('dropZone');
        
        dropZone.addEventListener('dragover', function(e) {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', function() {
            dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', function(e) {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) processFile(file);
        });

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) processFile(file);
        }

        // ==================== PNG è§£ææ ¸å¿ƒ ====================
        async function processFile(file) {
            originalFileName = file.name.replace(/\.(png|json)$/i, '');
            
            try {
                if (file.name.toLowerCase().endsWith('.json')) {
                    const text = await file.text();
                    originalData = JSON.parse(text);
                    cardImageDataUrl = '';
                    showCardPreview();
                } else if (file.name.toLowerCase().endsWith('.png')) {
                    const buffer = await file.arrayBuffer();
                    originalPngBuffer = new Uint8Array(buffer);
                    
                    // åˆ›å»ºå›¾ç‰‡é¢„è§ˆ
                    cardImageDataUrl = URL.createObjectURL(file);
                    
                    // è§£æ PNG chunks
                    const charaData = extractCharaFromPNG(originalPngBuffer);
                    if (charaData) {
                        originalData = JSON.parse(charaData);
                        showCardPreview();
                    } else {
                        throw new Error('æœªæ‰¾åˆ°è§’è‰²å¡æ•°æ®');
                    }
                } else {
                    throw new Error('ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼');
                }
                
                updateConvertButtonState();
                showToast('è§’è‰²å¡åŠ è½½æˆåŠŸï¼', 'success');
            } catch (error) {
                console.error(error);
                showToast('æ–‡ä»¶è§£æå¤±è´¥: ' + error.message, 'error');
            }
        }

        // PNG Chunk è§£æ
        function extractCharaFromPNG(buffer) {
            const view = new DataView(buffer.buffer);
            
            // éªŒè¯ PNG ç­¾å
            const signature = [137, 80, 78, 71, 13, 10, 26, 10];
            for (let i = 0; i < 8; i++) {
                if (buffer[i] !== signature[i]) {
                    throw new Error('æ— æ•ˆçš„ PNG æ–‡ä»¶');
                }
            }
            
            let offset = 8;
            
            while (offset < buffer.length) {
                const length = view.getUint32(offset);
                const typeBytes = buffer.slice(offset + 4, offset + 8);
                const type = String.fromCharCode.apply(null, typeBytes);
                
                if (type === 'tEXt' || type === 'iTXt') {
                    const data = buffer.slice(offset + 8, offset + 8 + length);
                    const result = parseTextChunk(data, type);
                    if (result && result.keyword === 'chara') {
                        try {
                            return atob(result.text);
                        } catch (e) {
                            return atob(result.text);
                        }
                    }
                }
                
                if (type === 'IEND') break;
                
                offset += 12 + length;
            }
            
            return null;
        }

        function parseTextChunk(data, type) {
            let nullIndex = data.indexOf(0);
            if (nullIndex === -1) return null;
            
            const keyword = String.fromCharCode.apply(null, data.slice(0, nullIndex));
            
            if (type === 'tEXt') {
                const text = String.fromCharCode.apply(null, data.slice(nullIndex + 1));
                return { keyword: keyword, text: text };
            } else if (type === 'iTXt') {
                let pos = nullIndex + 1;
                const compressionFlag = data[pos];
                const compressionMethod = data[pos + 1];
                pos += 2;
                
                while (pos < data.length && data[pos] !== 0) pos++;
                pos++;
                
                while (pos < data.length && data[pos] !== 0) pos++;
                pos++;
                
                const textBytes = data.slice(pos);
                const text = new TextDecoder('utf-8').decode(textBytes);
                return { keyword: keyword, text: text };
            }
            
            return null;
        }

        // ==================== æ˜¾ç¤ºå¡ç‰‡é¢„è§ˆ ====================
        function showCardPreview() {
            const preview = document.getElementById('cardPreview');
            preview.classList.remove('hidden');
            
            const img = document.getElementById('previewImage');
            if (cardImageDataUrl) {
                img.src = cardImageDataUrl;
                img.classList.remove('hidden');
            } else {
                img.classList.add('hidden');
            }
            
            const data = originalData.data || originalData;
            document.getElementById('cardName').textContent = data.name || 'æœªçŸ¥è§’è‰²';
            document.getElementById('cardCreator').textContent = data.creator ? 'by ' + data.creator : '';
            
            const
spec = originalData.spec || 'V1';
            const version = originalData.spec_version || '1.0';
            document.getElementById('cardSpec').textContent = spec + ' v' + version;
            document.getElementById('cardVersion').textContent = 
                data.character_version ? 'è§’è‰²ç‰ˆæœ¬: ' + data.character_version : '';
        }

        // ==================== æ›´æ–°è½¬æ¢æŒ‰é’®çŠ¶æ€ ====================
        function updateConvertButtonState() {
            const select = document.getElementById('modelSelect');
            const btn = document.getElementById('convertBtn');
            btn.disabled = !originalData || !select.value;
        }

        // ç›‘å¬æ¨¡å‹é€‰æ‹©å˜åŒ–
        document.getElementById('modelSelect').addEventListener('change', updateConvertButtonState);

        // ==================== AI è½¬æ¢æ ¸å¿ƒ ====================
        async function startConversion() {
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const apiKey = document.getElementById('apiKey').value.trim();
            const modelName = document.getElementById('modelSelect').value;
            
            if (!apiUrl || !apiKey || !modelName) {
                showToast('è¯·å¡«å†™å®Œæ•´çš„ API è®¾ç½®å¹¶é€‰æ‹©æ¨¡å‹', 'error');
                return;
            }
            
            if (!originalData) {
                showToast('è¯·å…ˆå¯¼å…¥è§’è‰²å¡', 'error');
                return;
            }
            
            document.getElementById('convertBtn').disabled = true;
            document.getElementById('progressSection').classList.remove('hidden');
            document.getElementById('diffSection').classList.add('hidden');
            document.getElementById('exportSection').classList.add('hidden');
            
            try {
                // æ·±æ‹·è´åŸå§‹æ•°æ®
                convertedData = JSON.parse(JSON.stringify(originalData));
                const data = convertedData.data || convertedData;
                
                // éœ€è¦å¤„ç†çš„å­—æ®µ
                const fields = [
                    { key: 'description', label: 'è§’è‰²æè¿°' },
                    { key: 'first_mes', label: 'é¦–æ¡æ¶ˆæ¯' },
                    { key: 'scenario', label: 'åœºæ™¯è®¾å®š' },
                    { key: 'mes_example', label: 'å¯¹è¯ç¤ºä¾‹' },
                    { key: 'personality', label: 'æ€§æ ¼ç‰¹å¾' },
                    { key: 'system_prompt', label: 'ç³»ç»Ÿæç¤ºè¯' }
                ];
                
                // å¤„ç† alternate_greetings
                const altGreetings = data.alternate_greetings || [];
                for (let i = 0; i < altGreetings.length; i++) {
                    fields.push({ key: 'alternate_greetings[' + i + ']', label: 'å¤‡ç”¨é—®å€™ ' + (i + 1), isAlt: true, index: i });
                }
                
                // è¿‡æ»¤ç©ºå­—æ®µ
                const validFields = fields.filter(function(f) {
                    if (f.isAlt) return altGreetings[f.index] && altGreetings[f.index].trim();
                    return data[f.key] && data[f.key].trim();
                });
                
                // åˆ›å»ºè¿›åº¦æ˜¾ç¤º
                const fieldProgress = document.getElementById('fieldProgress');
                fieldProgress.innerHTML = '';
                for (let i = 0; i < validFields.length; i++) {
                    const f = validFields[i];
                    const div = document.createElement('div');
                    div.className = 'flex items-center text-sm';
                    div.id = 'field-' + f.key.replace(/[\[\]]/g, '-');
                    div.innerHTML = '<span class="status-indicator pending"></span><span class="text-gray-400">' + f.label + '</span>';
                    fieldProgress.appendChild(div);
                }
                
                // é€ä¸ªå¤„ç†å­—æ®µ
                for (let i = 0; i < validFields.length; i++) {
                    const field = validFields[i];
                    const fieldId = 'field-' + field.key.replace(/[\[\]]/g, '-');
                    const fieldEl = document.getElementById(fieldId);
                    
                    // æ›´æ–°çŠ¶æ€ä¸ºå¤„ç†ä¸­
                    fieldEl.querySelector('.status-indicator').className = 'status-indicator processing';
                    
                    const progress = Math.round(((i + 0.5) / validFields.length) * 100);
                    document.getElementById('progressBar').style.width = progress + '%';
                    document.getElementById('progressStatus').textContent = 'æ­£åœ¨å¤„ç†: ' + field.label + '...';
                    
                    try {
                        let originalText;
                        if (field.isAlt) {
                            originalText = data.alternate_greetings[field.index];
                        } else {
                            originalText = data[field.key];
                        }
                        
                        const convertedText = await convertTextWithAI(originalText, apiUrl, apiKey, modelName);
                        
                        if (field.isAlt) {
                            data.alternate_greetings[field.index] = convertedText;
                        } else {
                            data[field.key] = convertedText;
                        }
                        
                        fieldEl.querySelector('.status-indicator').className = 'status-indicator done';
                    } catch (error) {
                        console.error('å¤„ç† ' + field.label + ' å¤±è´¥:', error);
                        fieldEl.querySelector('.status-indicator').className = 'status-indicator error';
                        const errorSpan = document.createElement('span');
                        errorSpan.className = 'text-red-400 ml-2 text-xs';
                        errorSpan.textContent = error.message;
                        fieldEl.appendChild(errorSpan);
                    }
                    
                    const finalProgress = Math.round(((i + 1) / validFields.length) * 100);
                    document.getElementById('progressBar').style.width = finalProgress + '%';
                }
                
                document.getElementById('progressStatus').textContent = 'è½¬æ¢å®Œæˆï¼';
                
                // æ˜¾ç¤º Diff å¯¹æ¯”
                showDiffPreview();
                
                document.getElementById('exportSection').classList.remove('hidden');
                showToast('è½¬æ¢å®Œæˆï¼', 'success');
                
            } catch (error) {
                console.error(error);
                showToast('è½¬æ¢å¤±è´¥: ' + error.message, 'error');
            }
            
            document.getElementById('convertBtn').disabled = false;
        }

        async function convertTextWithAI(text, apiUrl, apiKey, modelName) {
            if (!text || !text.trim()) return text;
            
            const genderTarget = targetGender === 'male' ? 'ç”·æ€§' : 'å¥³æ€§';
            const genderOpposite = targetGender === 'male' ? 'å¥³æ€§' : 'ç”·æ€§';
            
            const systemPrompt = 'ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„æ–‡æœ¬ç¼–è¾‘ä¸“å®¶ï¼Œä¸“é—¨ä»äº‹è§’è‰²æ‰®æ¼”æ¸¸æˆå†…å®¹çš„æœ¬åœ°åŒ–å’Œæ”¹ç¼–å·¥ä½œã€‚ä½ çš„ä»»åŠ¡æ˜¯å°†æ–‡æœ¬ä¸­å…³äº"ç”¨æˆ·/ç©å®¶/You/{{user}}"çš„æ€§åˆ«ç›¸å…³æè¿°è½¬æ¢ä¸ºç›®æ ‡æ€§åˆ«ã€‚\n\n## å·¥ä½œåŸåˆ™\n\n### 1. å¤–ç§‘æ‰‹æœ¯å¼ç²¾å‡†ä¿®æ”¹\n- ä»…ä¿®æ”¹ä¸ Userï¼ˆç”¨æˆ·/ç©å®¶/ä½ /{{user}}ï¼‰æ€§åˆ«ç›´æ¥ç›¸å…³çš„è¯æ±‡å’Œæè¿°\n- 100% ä¿ç•™åŸæ–‡çš„æ–‡é£ã€è¯­æ°”ã€æ ¼å¼ã€æ ‡ç‚¹ç¬¦å·\n- ä¸æ”¹å˜è§’è‰²(char/{{char}})çš„ä»»ä½•å±æ€§\n- ä¸æ·»åŠ åŸæ–‡æ²¡æœ‰çš„å†…å®¹ï¼Œä¸åˆ é™¤ä¸æ€§åˆ«æ— å…³çš„å†…å®¹\n\n### 2. éœ€è¦è½¬æ¢çš„å†…å®¹ç±»å‹\n- äººç§°ä»£è¯ï¼šå¥¹â†’ä»–ã€å¥¹çš„â†’ä»–çš„ï¼ˆæˆ–åå‘ï¼‰\n- ç§°å‘¼ï¼šå°å§â†’å…ˆç”Ÿã€å¥³å£«â†’ç”·å£«ã€å§å§â†’å“¥å“¥ï¼ˆæˆ–åå‘ï¼‰\n- èº«ä½“ç‰¹å¾æè¿°ï¼šèƒ¸éƒ¨â†’èƒ¸è†›ã€é˜´é“â†’é˜´èŒ/åç©´ã€å­å®«â†’å‰åˆ—è…ºç­‰\n- ç”Ÿç†ååº”ï¼šæ·«æ°´â†’å‰åˆ—è…ºæ¶²/è‚ æ¶²ã€æ½®å¹â†’å°„ç²¾ç­‰\n- æœè£…æè¿°ï¼šè£™å­â†’è£¤å­ã€èƒ¸ç½©â†’æ— ï¼ˆæ ¹æ®ä¸Šä¸‹æ–‡è°ƒæ•´ï¼‰\n\n### 3. å…³ç³»é€»è¾‘è¯†åˆ«\n- BGï¼ˆç”·å¥³ï¼‰æ¨¡å¼ï¼šæ­£å¸¸è½¬æ¢æ€§åˆ«è¯æ±‡\n- BLï¼ˆç”·ç”·ï¼‰æ¨¡å¼ï¼šå¦‚æœè§’è‰²æ˜¯ç”·æ€§ä¸”Userè½¬ä¸ºç”·æ€§ï¼Œéœ€å°†å¥³æ€§å™¨å®˜æå†™è½¬ä¸ºç”·æ€§å™¨å®˜ï¼ˆåç©´ã€è‚ æ¶²ç­‰ï¼‰\n- GLï¼ˆå¥³å¥³ï¼‰æ¨¡å¼ï¼šå¦‚æœè§’è‰²æ˜¯å¥³æ€§ä¸”Userè½¬ä¸ºå¥³æ€§ï¼Œä¿æŒå¥³æ€§å™¨å®˜æå†™\n\n### 4. å­¦æœ¯åŒ–å¤„ç†\n- å°†æ‰€æœ‰èº«ä½“éƒ¨ä½å’Œç”Ÿç†ç°è±¡è§†ä¸ºåŒ»å­¦/è§£å‰–å­¦æœ¯è¯­è¿›è¡Œä¸“ä¸šå¤„ç†\n- ä¿æŒæ–‡å­¦æ€§çš„åŒæ—¶ç¡®ä¿å‡†ç¡®æ€§\n\n## ç›®æ ‡æ€§åˆ«\nå°† User è½¬æ¢ä¸ºï¼š' + genderTarget + '\n\n## è¾“å‡ºè¦æ±‚\n- ç›´æ¥è¾“å‡ºä¿®æ”¹åçš„å®Œæ•´æ–‡æœ¬\n- ä¸è¦æ·»åŠ ä»»ä½•è§£é‡Šã€æ³¨é‡Šæˆ–è¯´æ˜\n- ä¸è¦ä½¿ç”¨ markdown æ ¼å¼åŒ…è£¹\n- ä¿æŒåŸæ–‡çš„æ‰€æœ‰æ ¼å¼ï¼ˆæ¢è¡Œã€ç©ºæ ¼ç­‰ï¼‰';

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + apiKey
                },
                body: JSON.stringify({
                    model: modelName,
                    messages: [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: text }
                    ],
                    temperature: 0.3,
                    max_tokens: 8192
                })
            });
            
            if (!response.ok) {
                const error = await response.text();
                throw new Error('API è¯·æ±‚å¤±è´¥: ' + response.status);
            }
            
            const result = await response.json();
            return result.choices[0].message.content;
        }

        // ==================== Diff å¯¹æ¯”æ˜¾ç¤º ====================
        function showDiffPreview() {
            document.getElementById('diffSection').classList.remove('hidden');
            const diffContent = document.getElementById('diffContent');
            
            const origData = originalData.data || originalData;
            const convData = convertedData.data || convertedData;
            
            const fields = [
                { key: 'description', label: 'è§’è‰²æè¿°' },
                { key: 'first_mes', label: 'é¦–æ¡æ¶ˆæ¯' },
                { key: 'scenario', label: 'åœºæ™¯è®¾å®š' },
                { key: 'mes_example', label: 'å¯¹è¯ç¤ºä¾‹' },
                { key: 'personality', label: 'æ€§æ ¼ç‰¹å¾' },
                { key: 'system_prompt', label: 'ç³»ç»Ÿæç¤ºè¯' }
            ];
            
            // æ·»åŠ  alternate_greetings
            const altGreetings = origData.alternate_greetings || [];
            for (let i = 0; i < altGreetings.length; i++) {
                fields.push({ key: 'alternate_greetings', label: 'å¤‡ç”¨é—®å€™ ' + (i + 1), index: i });
            }
            
            let html = '';
            
            for (let fi = 0; fi < fields.length; fi++) {
                const field = fields[fi];
                let origText, convText;
                
                if (field.index !== undefined) {
                    origText = (origData.alternate_greetings && origData.alternate_greetings[field.index]) || '';
                    convText = (convData.alternate_greetings && convData.alternate_greetings[field.index]) || '';
                } else {
                    origText = origData[field.key] || '';
                    convText = convData[field.key] || '';
                }
                
                if (!origText && !convText) continue;
                if (origText === convText) continue;
                
                const diffHtml = generateDiff(origText, convText);
                
                html += '<div class="field-item"><div class="collapsible-header" onclick="this.nextElementSibling.classList.toggle(\'open\'); this.querySelector(\'.chevron\').classList.toggle(\'open\')"><h3 class="font-medium text-purple-300">' + field.label + '</h3><span class="chevron text-gray-500">â–¼</span></div><div class="collapsible-content open"><div class="preview-section mt-3 text-sm text-gray-300 whitespace-pre-wrap break-words">' + diffHtml + '</div></div></div>';
            }
            
            diffContent.innerHTML = html || '<p class="text-gray-500 text-center">æ²¡æœ‰æ£€æµ‹åˆ°å˜æ›´</p>';
        }

        function generateDiff(oldText, newText) {
            // ç®€å•çš„è¯çº§åˆ« diff
            const oldWords = oldText.split(/(\s+)/);
            const newWords = newText.split(/(\s+)/);
            
            // ä½¿ç”¨ LCS ç®—æ³•çš„ç®€åŒ–ç‰ˆæœ¬
            let result = '';
            let i = 0, j = 0;
            
            while (i < oldWords.length || j < newWords.length) {
                if (i >= oldWords.length) {
                    result += '<span class="diff-added">' + escapeHtml(newWords[j]) + '</span>';
                    j++;
                } else if (j >= newWords.length) {
                    result += '<span class="diff-removed">' + escapeHtml(oldWords[i]) + '</span>';
                    i++;
                } else if (oldWords[i] === newWords[j]) {
                    result += escapeHtml(oldWords[i]);
                    i++;
                    j++;
                } else {
                    // æŸ¥æ‰¾åŒ¹é…
                    let foundInNew = newWords.indexOf(oldWords[i], j);
                    let foundInOld = oldWords.indexOf(newWords[j], i);
                    
                    if (foundInNew !== -1 && (foundInOld === -1 || foundInNew - j < foundInOld - i)) {
                        // æ–°æ–‡æœ¬æœ‰æ’å…¥
                        while (j < foundInNew) {
                            result += '<span class="diff-added">' + escapeHtml(newWords[j]) + '</span>';
                            j++;
                        }
                    } else if (foundInOld !== -1) {
                        // æ—§æ–‡æœ¬æœ‰åˆ é™¤
                        while (i < foundInOld) {
                            result += '<span class="diff-removed">' + escapeHtml(oldWords[i]) + '</span>';
                            i++;
                        }
                    } else {
                        // æ›¿æ¢
                        result += '<span class="diff-removed">' + escapeHtml(oldWords[i]) + '</span>';
                        result += '<span class="diff-added">' + escapeHtml(newWords[j]) + '</span>';
                        i++;
                        j++;
                    }
                }
            }
            
            return result;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ==================== å¯¼å‡ºåŠŸèƒ½ ====================
        function exportJSON() {
            if (!convertedData) {
                showToast('æ²¡æœ‰å¯å¯¼å‡ºçš„æ•°æ®', 'error');
                return;
            }
            
            const genderSuffix = targetGender === 'male' ? 'Male_User' : 'Female_User';
            const fileName = originalFileName + '_' + genderSuffix + '.json';
            
            const blob = new Blob([JSON.stringify(convertedData, null, 2)], { type: 'application/json' });
            downloadBlob(blob, fileName);
            showToast('JSON å¯¼å‡ºæˆåŠŸï¼', 'success');
        }

        async function exportPNG() {
            if (!convertedData) {
                showToast('æ²¡æœ‰å¯å¯¼å‡ºçš„æ•°æ®', 'error');
                return;
            }
            
            if (!originalPngBuffer) {
                showToast('åŸå§‹ PNG ä¸å¯ç”¨ï¼Œè¯·ä¸‹è½½ JSON', 'error');
                return;
            }
            
            try {
                const charaJson = JSON.stringify(convertedData);
                const charaBase64 = btoa(unescape(encodeURIComponent(charaJson)));
                
                const newPngBuffer = replaceCharaInPNG(originalPngBuffer, charaBase64);
                
                const genderSuffix = targetGender === 'male' ? 'Male_User' : 'Female_User';
                const fileName = originalFileName + '_' + genderSuffix + '.png';
                
                const blob = new Blob([newPngBuffer], { type: 'image/png' });
                downloadBlob(blob, fileName);
                showToast('PNG å¯¼å‡ºæˆåŠŸï¼', 'success');
            } catch (error) {
                console.error(error);
                showToast('PNG å¯¼å‡ºå¤±è´¥: ' + error.message, 'error');
            }
        }

        function replaceCharaInPNG(buffer, newCharaBase64) {
            const chunks = [];
            const view = new DataView(buffer.buffer);
            
            // PNG ç­¾å
            chunks.push(buffer.slice(0, 8));
            
            let offset = 8;
            let insertedChara = false;
            
            while (offset < buffer.length) {
                const length = view.getUint32(offset);
                const typeBytes = buffer.slice(offset + 4, offset + 8);
                const type = String.fromCharCode.apply(null, typeBytes);
                const chunkData = buffer.slice(offset, offset + 12 + length);
                
                if ((type === 'tEXt' || type === 'iTXt') && !insertedChara) {
                    const data = buffer.slice(offset + 8, offset + 8 + length);
                    let nullIndex = data.indexOf(0);
                    const keyword = String.fromCharCode.apply(null, data.slice(0, nullIndex));
                    
                    if (keyword === 'chara') {
                        // æ›¿æ¢è¿™ä¸ª chunk
                        const newChunk = createTEXtChunk('chara', newCharaBase64);
                        chunks.push(newChunk);
                        insertedChara = true;
                        offset += 12 + length;
                        continue;
                    }
                }
                
                // åœ¨ IDAT ä¹‹å‰æ’å…¥ chara chunkï¼ˆå¦‚æœè¿˜æ²¡æ’å…¥ï¼‰
                if (type === 'IDAT' && !insertedChara) {
                    const newChunk = createTEXtChunk('chara', newCharaBase64);
                    chunks.push(newChunk);
                    insertedChara = true;
                }
                
                chunks.push(chunkData);
                
                if (type === 'IEND') break;
                
                offset += 12 + length;
            }
            
            // åˆå¹¶æ‰€æœ‰ chunks
            const totalLength = chunks.reduce(function(sum, chunk) { return sum + chunk.length; }, 0);
            const result = new Uint8Array(totalLength);
            let pos = 0;
            for (let i = 0; i < chunks.length; i++) {
                result.set(chunks[i], pos);
                pos += chunks[i].length;
            }
            
            return result;
        }

        function createTEXtChunk(keyword, text) {
            const keywordBytes = new TextEncoder().encode(keyword);
            const textBytes = new TextEncoder().encode(text);
            
            const dataLength = keywordBytes.length + 1 + textBytes.length;
            const chunk = new Uint8Array(12 + dataLength);
            const view = new DataView(chunk.buffer);
            
            // Length
            view.setUint32(0, dataLength);
            
            // Type: tEXt
            chunk[4] = 0x74; // t
            chunk[5] = 0x45; // E
            chunk[6] = 0x58; // X
            chunk[7] = 0x74; // t
            
            // Data: keyword + null + text
            chunk.set(keywordBytes, 8);
            chunk[8 + keywordBytes.length] = 0;
            chunk.set(textBytes, 9 + keywordBytes.length);
            
            // CRC
            const crc = calculateCRC(chunk.slice(4, 8 + dataLength));
            view.setUint32(8 + dataLength, crc);
            
            return chunk;
        }

        // CRC32 è®¡ç®—
        function calculateCRC(data) {
            let crc = 0xFFFFFFFF;
            const table = getCRCTable();
            
            for (let i = 0; i < data.length; i++) {
                crc = (crc >>> 8) ^ table[(crc ^ data[i]) & 0xFF];
            }
            
            return (crc ^ 0xFFFFFFFF) >>> 0;
        }

        let crcTable = null;
        function getCRCTable() {
            if (crcTable) return crcTable;
            
            crcTable = new Uint32Array(256);
            for (let i = 0; i < 256; i++) {
                let c = i;
                for (let j = 0; j < 8; j++) {
                    c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                }
                crcTable[i] = c;
            }
            return crcTable;
        }

        function downloadBlob(blob, fileName) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
